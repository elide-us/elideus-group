from typing import Any, Union, get_origin, get_args
from pydantic import BaseModel
import os, importlib.util, types
from pathlib import Path
from datetime import datetime

# Root of the repository relative to this file
REPO_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

# Root of the solution using Pathlib
ROOT = Path(__file__).resolve().parent.parent

# Map bare Python types to TS primitives (won't be used for generic types)
PY_TO_TS = {
  str: 'string',
  int: 'number',
  float: 'number',
  bool: 'boolean',
  type(None): 'null',
  dict: 'Record<string, any>',
  datetime: 'string',
  list: 'any[]',  # fallback for untyped list
}

# Standard header included at the top of generated files
HEADER_COMMENT = [
  "// ================================================",
  "// WARNING: This file is automatically generated.",
  "// Do not modify it by hand. Your changes will be",
  "// overwritten the next time the generator runs.",
  "// ================================================",
  "",
]


def camel_case(name: str) -> str:
  """Convert snake_case names to CamelCase."""
  return "".join(part.capitalize() for part in name.split("_"))


def load_module(path: str) -> types.ModuleType:
  module_name = os.path.splitext(os.path.basename(path))[0] + "_tmp"
  spec = importlib.util.spec_from_file_location(module_name, path)
  if not spec or not spec.loader:
    raise ImportError(f"Could not load spec for module at {path}")
  module = importlib.util.module_from_spec(spec)
  spec.loader.exec_module(module)
  return module


def py_to_ts(py_type: Any) -> str:
  origin = get_origin(py_type)
  args = get_args(py_type)

  # Handle generics: List[X] or Tuple[X, ...]
  if origin in (list, tuple):
    inner_type = py_to_ts(args[0]) if args else 'any'
    return f"{inner_type}[]"

  # Handle Optional[X] (i.e. Union[X, None])
  if origin is Union:
    non_none = [arg for arg in args if arg is not type(None)]
    if len(non_none) == 1:
      return f"{py_to_ts(non_none[0])} | null"
    return " | ".join(py_to_ts(arg) for arg in args)

  # Known primitives
  if py_type in PY_TO_TS:
    return PY_TO_TS[py_type]

  # Pydantic models â†’ use interface name
  if isinstance(py_type, type) and issubclass(py_type, BaseModel):
    return py_type.__name__

  # Fallback
  return 'any'


def model_to_ts(model: type[BaseModel]) -> str:
  lines = [f"export interface {model.__name__} {{"]
  fields = getattr(model, 'model_fields', None) or getattr(model, '__fields__', {})
  for name, field in fields.items():
    annotation = getattr(field, 'annotation', None) or getattr(field, 'outer_type_', None)
    ts_type = py_to_ts(annotation)
    lines.append(f"  {name}: {ts_type};")
  lines.append("}")
  return "\n".join(lines)


def parse_version(ver: str) -> tuple[int, int, int, int]:
  """Convert a version string like 'v1.2.3.4' into its numeric parts."""
  ver = ver.lstrip('v')
  major, minor, patch, build = [int(p) for p in ver.split('.')]
  return major, minor, patch, build


def next_build(current_version: str, last_version: str) -> int:
  """Return the next build number for the given versions.

  The build number is reset only when the major or minor version changes.
  Patch version bumps continue the build count within the same minor version.
  """
  cur_major, cur_minor, _, cur_build = parse_version(current_version)
  last_major, last_minor, _, _ = parse_version(last_version)
  if (cur_major, cur_minor) != (last_major, last_minor):
    return 1
  return cur_build + 1


def bump_version(version: str, part: str) -> str:
  """Increment the specified part of a version string.

  Parts can be 'major', 'minor', 'patch', or 'build'.
  Major/minor bumps reset lower-order fields to 0.
  """
  ma, mi, pa, bu = parse_version(version)
  match part:
    case 'major':
      ma += 1
      mi = 0
      pa = 0
      bu = 0
    case 'minor':
      mi += 1
      pa = 0
      bu = 0
    case 'patch':
      pa += 1
    case 'build':
      bu += 1
    case _:
      raise ValueError(f"Unknown part: {part}")
  return f"v{ma}.{mi}.{pa}.{bu}"

