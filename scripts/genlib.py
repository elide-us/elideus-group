from typing import Any, Union, get_origin, get_args
from pydantic import BaseModel
import os, importlib.util, types
from pathlib import Path

# Root of the repository relative to this file
REPO_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

# Root of the solution using Pathlib
ROOT = Path(__file__).resolve().parent.parent

# Map bare Python types to TS primitives (won't be used for generic types)
PY_TO_TS = {
  str: 'string',
  int: 'number',
  float: 'number',
  bool: 'boolean',
  type(None): 'null',
  dict: 'Record<string, any>',
  list: 'any[]',  # fallback for untyped list
}

# Standard header included at the top of generated files
HEADER_COMMENT = [
  "// ================================================",
  "// WARNING: This file is automatically generated.",
  "// Do not modify it by hand. Your changes will be",
  "// overwritten the next time the generator runs.",
  "// ================================================",
  "",
]

def camel_case(name: str) -> str:
  """Convert snake_case names to CamelCase."""
  return "".join(part.capitalize() for part in name.split("_"))

# def load_module(path: str):
#   spec = importlib.util.spec_from_file_location("mod", path)
#   module = importlib.util.module_from_spec(spec)
#   spec.loader.exec_module(module)  # type: ignore[attr-defined]
#   return module

def load_module(path: str) -> types.ModuleType:
    module_name = os.path.splitext(os.path.basename(path))[0] + "_tmp"
    spec = importlib.util.spec_from_file_location(module_name, path)
    if not spec or not spec.loader:
        raise ImportError(f"Could not load spec for module at {path}")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

def py_to_ts(py_type: Any) -> str:
  origin = get_origin(py_type)
  args = get_args(py_type)

  # Handle generics: List[X] or Tuple[X, ...]
  if origin in (list, tuple):
    inner_type = py_to_ts(args[0]) if args else 'any'
    return f"{inner_type}[]"

  # Handle Optional[X] (i.e. Union[X, None])
  if origin is Union:
    non_none = [arg for arg in args if arg is not type(None)]
    if len(non_none) == 1:
      return f"{py_to_ts(non_none[0])} | null"
    return " | ".join(py_to_ts(arg) for arg in args)

  # Known primitives
  if py_type in PY_TO_TS:
    return PY_TO_TS[py_type]

  # Pydantic models â†’ use interface name
  if isinstance(py_type, type) and issubclass(py_type, BaseModel):
    return py_type.__name__

  # Fallback
  return 'any'

def model_to_ts(model: type[BaseModel]) -> str:
  lines = [f"export interface {model.__name__} {{"]
  fields = getattr(model, 'model_fields', None) or getattr(model, '__fields__', {})
  for name, field in fields.items():
    annotation = getattr(field, 'annotation', None) or getattr(field, 'outer_type_', None)
    ts_type = py_to_ts(annotation)
    lines.append(f"  {name}: {ts_type};")
  lines.append("}")
  return "\n".join(lines)
